<!-- =======================
     JENDCO HARD HAT CUSTOMIZER (WYSIWYG SAFE, INLINE STYLES)
     ======================= -->
<div id="vest-customizer-root" style="max-width: 1200px; margin: 0 auto; padding: 16px;">
<h1 style="text-align: center; margin: 0 0 8px 0;"><img src="https://cdn11.bigcommerce.com/s-ap39xxpmw2/images/stencil/original/image-manager/tablet-banner.png" alt="Jendco" style="width: 25%; height: auto; max-width: 280px;" /></h1>
<h2 style="text-align: center; margin: 0 0 20px 0; font-weight: bold; color: #111;">Jendco Hard Hat Logo</h2>
<!-- Vendor -->
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;"><label for="vendor" style="width: 180px; font-weight: 600;">Vendor</label><select id="vendor" style="flex: 1; border: 1px solid #ccc; border-radius: 6px; padding: 6px 10px; font-size: 14px;">
<option value="">-- Select Vendor --</option>
<option value="Kask">Kask</option>
<option value="Lift">Lift Safety</option>
<option value="MSA">MSA</option>
<option value="Studson">Studson</option>
<option value="Other">Other</option>
</select></div>
<!-- Hard Hat Variant -->
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;"><label for="variantSel" style="width: 180px; font-weight: 600;">Hard Hat Variant</label><select id="variantSel" style="flex: 1; border: 1px solid #ccc; border-radius: 6px; padding: 6px 10px; font-size: 14px;"><!-- JS will inject helmet options here --></select></div>
<!-- Color Selection -->
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;"><label for="colorSel" style="width: 180px; font-weight: 600;">Color</label><select id="colorSel" style="flex: 1; border: 1px solid #ccc; border-radius: 6px; padding: 6px 10px; font-size: 14px;" disabled="disabled">
<option value="">-- Select Hard Hat First --</option>
</select></div>
<!-- Product Style -->
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;"><label for="productStyle" style="width: 180px; font-weight: 600;">Product Code</label> <input id="productStyle" type="text" placeholder="e.g., Full Brim, Climbing Style" style="flex: 1; border: 1px solid #ccc; border-radius: 6px; padding: 6px 10px; font-size: 14px;" /></div>
<!-- 2×2 Canvas Grid -->
<div class="grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 18px; align-items: flex-start;"><!-- FRONT -->
<div class="panel" id="frontPanel" style="border: 1px solid #e6e6e6; border-radius: 12px; padding: 12px; background: #fff; box-shadow: 0 6px 20px rgba(15,23,42,.08);">
<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
<div style="font-weight: bold;">Front</div>
<div style="display: flex; align-items: center; gap: 8px;"><span id="selFront" style="font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #f4f4f5;"><b>File:</b> None</span> <span id="dpiFront" style="font-size: 11px; padding: 3px 8px; border-radius: 999px; background: #f4f4f5; display: none;"></span></div>
</div>
<div style="display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0;"><label class="btn outline" style="position: relative; display: inline-block;"> Upload to Front <input type="file" id="upFront" accept=".png,.jpg,.jpeg,.webp,.svg" style="display: none;" /> </label> <button class="btn outline" id="textFrontBtn">Text</button> <button class="btn outline" id="cloneFtoAll">Clone selected &rarr; All</button> <button class="btn outline" id="delFront">Delete Selected</button></div>
<div id="textFrontControls" style="display: none; align-items: center; gap: 8px; flex-wrap: wrap; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; margin: 0 0 10px 0;">
  <input id="textFrontInput" type="text" maxlength="60" placeholder="Add text" style="flex: 1; min-width: 180px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <select id="textFrontFont" style="padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
    <option value="Arial" selected="selected">Arial</option>
    <option value="Helvetica">Helvetica</option>
    <option value="Times New Roman">Times New Roman</option>
    <option value="Verdana">Verdana</option>
    <option value="Impact">Impact</option>
  </select>
  <input id="textFrontSize" type="number" min="8" max="96" value="24" style="width: 70px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <input id="textFrontColor" type="color" value="#111111" style="width: 46px; height: 36px; padding: 0; border: 1px solid #d1d5db; border-radius: 6px;" />
  <button type="button" class="btn" id="textFrontApply">Place Text</button>
  <button type="button" class="btn outline" id="textFrontCancel">Cancel</button>
</div>
<div style="font-size: 12px; color: #4b5563; margin: -6px 0 8px 0;">Accepted formats: PNG, JPG, JPEG, WEBP, SVG</div>
<div style="border: 1px solid #eee; border-radius: 10px; overflow: hidden; background: #fff;">
<div id="stageFront"></div>
</div>
</div>
<!-- BACK -->
<div class="panel" id="backPanel" style="border: 1px solid #e6e6e6; border-radius: 12px; padding: 12px; background: #fff; box-shadow: 0 6px 20px rgba(15,23,42,.08);">
<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
<div style="font-weight: bold;">Back</div>
<div style="display: flex; align-items: center; gap: 8px;"><span id="selBack" style="font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #f4f4f5;"><b>File:</b> None</span> <span id="dpiBack" style="font-size: 11px; padding: 3px 8px; border-radius: 999px; background: #f4f4f5; display: none;"></span></div>
</div>
<div style="display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0;"><label class="btn outline" style="position: relative; display: inline-block;"> Upload to Back <input type="file" id="upBack" accept=".png,.jpg,.jpeg,.webp,.svg" style="display: none;" /> </label> <button class="btn outline" id="textBackBtn">Text</button> <button class="btn outline" id="cloneBtoAll">Clone selected &rarr; All</button> <button class="btn outline" id="delBack">Delete Selected</button></div>
<div id="textBackControls" style="display: none; align-items: center; gap: 8px; flex-wrap: wrap; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; margin: 0 0 10px 0;">
  <input id="textBackInput" type="text" maxlength="60" placeholder="Add text" style="flex: 1; min-width: 180px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <select id="textBackFont" style="padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
    <option value="Arial" selected="selected">Arial</option>
    <option value="Helvetica">Helvetica</option>
    <option value="Times New Roman">Times New Roman</option>
    <option value="Verdana">Verdana</option>
    <option value="Impact">Impact</option>
  </select>
  <input id="textBackSize" type="number" min="8" max="96" value="24" style="width: 70px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <input id="textBackColor" type="color" value="#111111" style="width: 46px; height: 36px; padding: 0; border: 1px solid #d1d5db; border-radius: 6px;" />
  <button type="button" class="btn" id="textBackApply">Place Text</button>
  <button type="button" class="btn outline" id="textBackCancel">Cancel</button>
</div>
<div style="font-size: 12px; color: #4b5563; margin: -6px 0 8px 0;">Accepted formats: PNG, JPG, JPEG, WEBP, SVG</div>
<div style="border: 1px solid #eee; border-radius: 10px; overflow: hidden; background: #fff;">
<div id="stageBack"></div>
</div>
</div>
<!-- LEFT -->
<div class="panel" id="leftPanel" style="border: 1px solid #e6e6e6; border-radius: 12px; padding: 12px; background: #fff; box-shadow: 0 6px 20px rgba(15,23,42,.08);">
<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
<div style="font-weight: bold;">Left</div>
<div style="display: flex; align-items: center; gap: 8px;"><span id="selLeft" style="font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #f4f4f5;"><b>File:</b> None</span> <span id="dpiLeft" style="font-size: 11px; padding: 3px 8px; border-radius: 999px; background: #f4f4f5; display: none;"></span></div>
</div>
<div style="display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0;"><label class="btn outline" style="position: relative; display: inline-block;"> Upload to Left <input type="file" id="upLeft" accept=".png,.jpg,.jpeg,.webp,.svg" style="display: none;" /> </label> <button class="btn outline" id="textLeftBtn">Text</button> <button class="btn outline" id="cloneLtoAll">Clone selected &rarr; All</button> <button class="btn outline" id="delLeft">Delete Selected</button></div>
<div id="textLeftControls" style="display: none; align-items: center; gap: 8px; flex-wrap: wrap; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; margin: 0 0 10px 0;">
  <input id="textLeftInput" type="text" maxlength="60" placeholder="Add text" style="flex: 1; min-width: 180px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <select id="textLeftFont" style="padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
    <option value="Arial" selected="selected">Arial</option>
    <option value="Helvetica">Helvetica</option>
    <option value="Times New Roman">Times New Roman</option>
    <option value="Verdana">Verdana</option>
    <option value="Impact">Impact</option>
  </select>
  <input id="textLeftSize" type="number" min="8" max="96" value="24" style="width: 70px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <input id="textLeftColor" type="color" value="#111111" style="width: 46px; height: 36px; padding: 0; border: 1px solid #d1d5db; border-radius: 6px;" />
  <button type="button" class="btn" id="textLeftApply">Place Text</button>
  <button type="button" class="btn outline" id="textLeftCancel">Cancel</button>
</div>
<div style="font-size: 12px; color: #4b5563; margin: -6px 0 8px 0;">Accepted formats: PNG, JPG, JPEG, WEBP, SVG</div>
<div style="border: 1px solid #eee; border-radius: 10px; overflow: hidden; background: #fff;">
<div id="stageLeft"></div>
</div>
</div>
<!-- RIGHT -->
<div class="panel" id="rightPanel" style="border: 1px solid #e6e6e6; border-radius: 12px; padding: 12px; background: #fff; box-shadow: 0 6px 20px rgba(15,23,42,.08);">
<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
<div style="font-weight: bold;">Right</div>
<div style="display: flex; align-items: center; gap: 8px;"><span id="selRight" style="font-size: 12px; padding: 4px 8px; border-radius: 999px; background: #f4f4f5;"><b>File:</b> None</span> <span id="dpiRight" style="font-size: 11px; padding: 3px 8px; border-radius: 999px; background: #f4f4f5; display: none;"></span></div>
</div>
<div style="display: flex; gap: 8px; flex-wrap: wrap; margin: 10px 0;"><label class="btn outline" style="position: relative; display: inline-block;"> Upload to Right <input type="file" id="upRight" accept=".png,.jpg,.jpeg,.webp,.svg" style="display: none;" /> </label> <button class="btn outline" id="textRightBtn">Text</button> <button class="btn outline" id="cloneRtoAll">Clone selected &rarr; All</button> <button class="btn outline" id="delRight">Delete Selected</button></div>
<div id="textRightControls" style="display: none; align-items: center; gap: 8px; flex-wrap: wrap; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; margin: 0 0 10px 0;">
  <input id="textRightInput" type="text" maxlength="60" placeholder="Add text" style="flex: 1; min-width: 180px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <select id="textRightFont" style="padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
    <option value="Arial" selected="selected">Arial</option>
    <option value="Helvetica">Helvetica</option>
    <option value="Times New Roman">Times New Roman</option>
    <option value="Verdana">Verdana</option>
    <option value="Impact">Impact</option>
  </select>
  <input id="textRightSize" type="number" min="8" max="96" value="24" style="width: 70px; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;" />
  <input id="textRightColor" type="color" value="#111111" style="width: 46px; height: 36px; padding: 0; border: 1px solid #d1d5db; border-radius: 6px;" />
  <button type="button" class="btn" id="textRightApply">Place Text</button>
  <button type="button" class="btn outline" id="textRightCancel">Cancel</button>
</div>
<div style="font-size: 12px; color: #4b5563; margin: -6px 0 8px 0;">Accepted formats: PNG, JPG, JPEG, WEBP, SVG</div>
<div style="border: 1px solid #eee; border-radius: 10px; overflow: hidden; background: #fff;">
<div id="stageRight"></div>
</div>
</div>
</div>
<!-- Order / Print Details -->
<div class="panel" style="border: 1px solid #e6e6e6; border-radius: 12px; padding: 12px; background: #fff; margin-top: 12px; box-shadow: 0 6px 20px rgba(15,23,42,.08);">
<h3 align="center" style="margin: 8px 0 16px 0;"><u><font size="5">Order / Print Details</font></u></h3>
<!-- Logo Location -->
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;"><label for="logoLoc" style="width: 180px; font-weight: 600;">Logo Location</label><select id="logoLoc" style="flex: 1; border: 1px solid #ccc; border-radius: 6px; padding: 6px 10px; font-size: 14px;">
<option value="Front">Front</option>
<option value="Back">Back</option>
<option value="Left">Left</option>
<option value="Right">Right</option>
</select></div>
<!-- Quantity -->
<div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;"><label for="qty" style="width: 180px; font-weight: 600;">Quantity</label> <input id="qty" type="number" min="0" step="1" value="0" style="flex: 1; border: 1px solid #ccc; border-radius: 6px; padding: 6px 10px; font-size: 14px;" /></div>
<!-- Customer Info -->
<div id="custInfo" style="display: grid; grid-template-columns: 180px 260px; gap: 6px 10px; align-items: center; max-width: 480px; margin-top: 12px;">
<div style="grid-column: 1/-1; font-weight: 600; margin-bottom: 4px;"><u><font size="5">Customer Information</font></u></div>
<span>Customer Name</span><input id="custName" type="text" placeholder="Company / Organization" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box;" required="required" /> <span>Contact Name</span><input id="contactName" type="text" placeholder="Full name" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box;" required="required" /> <span>Email</span><input id="custEmail" type="email" placeholder="name@example.com" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box;" required="required" /> <span>Phone</span><input id="custPhone" type="tel" placeholder="(555) 555-5555" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box;" required="required" /> <span>Sales Order #</span><input id="salesOrder" type="text" placeholder="e.g., SO-12345" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box;" required="required" /> <span>Notes</span><input id="custNotes" type="text" maxlength="140" placeholder="Enter up to 140 characters" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box;" /></div>
<div style="margin-top: 20px; text-align: left;"><button id="downloadProof" class="btn" style="background: #ff7a00; color: #fff; border: none; padding: 10px 20px; border-radius: 6px; font-size: 15px; cursor: pointer;">Download Proof PDF</button></div>
</div>
</div>
<!-- Libraries -->
<p>
<script src="https://cdn.jsdelivr.net/npm/konva@9.3.16/konva.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
<script>
(function(){
/* -----------------------------
 * Config / Variants (your URLs)
 * ----------------------------- */

const LOGO_URL = "https://cdn11.bigcommerce.com/s-ap39xxpmw2/images/stencil/original/image-manager/tablet-banner.png";
const STAGE_REFERENCE_INCHES = 6;

let hasUnsavedChanges = false;
const markUnsaved = () => { hasUnsavedChanges = true; };
const markSaved = () => { hasUnsavedChanges = false; };

window.addEventListener('beforeunload', (event) => {
  if (!hasUnsavedChanges) return;
  const message = 'Please download and save your proof before leaving this page.';
  event.preventDefault();
  event.returnValue = message;
  return message;
});

// Print area dimensions (as percentage of helmet base image)
const PRINT_AREA_CONFIG = {
  front: { x: 0.30, y: 0.05, width: 0.40, height: 0.30 },  // centered rectangle
  back:  { x: 0.30, y: 0.05, width: 0.40, height: 0.30 },
  left:  { x: 0.35, y: 0.05, width: 0.30, height: 0.25 },  // side positioning
  right: { x: 0.35, y: 0.05, width: 0.30, height: 0.25 }
};

let VARIANTS = {};
let variantsPromise = null;

  /* -----------------
   * Utilities / DOM
   * ----------------- */
  function loadImage(url){
    return new Promise((res,rej)=>{
      if(!url){ res(null); return; }
      const i=new Image(); i.crossOrigin='anonymous';
      i.onload=()=>res(i); i.onerror=()=>rej(new Error('load '+url)); i.src=url;
    });
  }
  function fileToDataURL(file){
    return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsDataURL(file); });
  }
function calculateDPI(imageWidth, imageHeight, printWidthInches, printHeightInches) {
  const dpiX = imageWidth / printWidthInches;
  const dpiY = imageHeight / printHeightInches;
  return Math.min(dpiX, dpiY); // Use the lower DPI (worst case)
}

function getDPIQuality(dpi) {
  if (dpi >= 300) return { level: 'Good', color: '#10b981', bg: '#d1fae5' }; // Green
  if (dpi >= 150) return { level: 'OK', color: '#f59e0b', bg: '#fef3c7' };   // Amber
  return { level: 'Bad', color: '#ef4444', bg: '#fee2e2' };                  // Red
}

  /* -------------
   * Side manager
   * ------------- */

class Side {
    constructor(opts){
      this.id=opts.id;
      this.mountId=opts.mountId;
      this.selBadge=document.getElementById(opts.selBadgeId);
      this.dpiBadge=document.getElementById(opts.dpiBadgeId);
      this.deleteBtn=document.getElementById(opts.deleteBtnId);
      this.uploadInp=document.getElementById(opts.uploadId);
      this.textBtn=document.getElementById(opts.textBtnId);
      this.textControls={
        wrapper: document.getElementById(opts.textControlsId),
        input: document.getElementById(opts.textInputId),
        font: document.getElementById(opts.textFontId),
        size: document.getElementById(opts.textSizeId),
        color: document.getElementById(opts.textColorId),
        apply: document.getElementById(opts.textApplyId),
        cancel: document.getElementById(opts.textCancelId)
      };
      this.textDefaults={font:'Arial',size:24,color:'#111111'};
      if(this.textControls.wrapper){
        this.textControls.wrapper.dataset.mode='add';
      }
      if(this.textControls.input){
        this.textControls.input.addEventListener('keydown',(ev)=>{
          if(ev.key==='Enter' && !ev.shiftKey && !ev.ctrlKey && !ev.metaKey && !ev.altKey && !ev.isComposing){
            ev.preventDefault();
            this.applyTextFromControls();
          }
        });
      }
      if(this.textBtn && this.textControls.wrapper){
        this.textBtn.addEventListener('click',()=> this.handleTextButton());
        if(this.textControls.cancel){
          this.textControls.cancel.addEventListener('click',()=> this.hideTextControls());
        }
        if(this.textControls.apply){
          this.textControls.apply.addEventListener('click',()=> this.applyTextFromControls());
        }
      }
      if(this.textControls.wrapper){
        this.prepareTextFormDefaults();
      }

      const mount=document.getElementById(this.mountId);
      const W=Math.min(560,(mount.clientWidth||560));
      this.stage=new Konva.Stage({container:this.mountId,width:W,height:W});
      this.layerBg=new Konva.Layer();
      this.layerArt=new Konva.Layer();
      this.layerArt.on('add', (evt)=>{
        const node = evt && evt.target;
        if (!node) return;
        if (typeof node.name === 'function' && node.name() === 'draggableItem') {
          markUnsaved();
        }
      });
      this.layerUI=new Konva.Layer();
      this.stage.add(this.layerBg,this.layerArt,this.layerUI);

      this.tr=new Konva.Transformer({
        nodes:[], rotateEnabled:true,
        enabledAnchors:['top-left','top-right','bottom-left','bottom-right'],
        boundBoxFunc:(oldB,newB)=>{const MIN=20;return (newB.width<MIN||newB.height<MIN)?oldB:newB;}
      });
      this.layerUI.add(this.tr);

      this.bounds={x:0,y:0,w:W,h:W};
      this.baseNode=null;
      this.printAreaRect=null;

      // selection
      this.stage.on('click', e=>{
        if (e.target===this.stage || e.target===this.baseNode){ this.setSelected(null); return; }
        const n=e.target.findAncestor('.draggableItem', true);
        if(n) this.setSelected(n);
      });

      // upload
      this.uploadInp.addEventListener('change', async (e)=>{
        try{
          const f=e.target.files && e.target.files[0]; if(!f) return;
          const dataURL=await fileToDataURL(f);
          const img=await loadImage(dataURL);
          const iw=img.naturalWidth||img.width, ih=img.naturalHeight||img.height;
          const maxW=this.bounds.w*0.6, maxH=this.bounds.h*0.6;
          const scale=Math.min(maxW/iw, maxH/ih, 1);

          const targetBounds = this.printBounds || this.bounds;
          const node=new Konva.Image({
            image:img,
            x: targetBounds.x + (targetBounds.w - iw*scale)/2,
            y: targetBounds.y + (targetBounds.h - ih*scale)/2,
            width:iw*scale, height:ih*scale,
            draggable:true, name:'draggableItem', label:f.name
          });
          this.attachHandlersForNode(node);
          this.layerArt.add(node);
          this.clamp(node);
          this.layerArt.draw();
          markUnsaved();
          this.setSelected(node);

          window.lastUpload={side:this,node};
          e.target.value='';
        }catch(err){ alert('Upload failed: '+(err?.message||err)); }
      });

      // delete
      this.deleteBtn.addEventListener('click', ()=>{
        const sel=this.selected(); if(!sel) return;
        sel.destroy();
        this.layerArt.draw();
        this.setSelected(null);
        markUnsaved();
      });
    }

    drawPrintArea() {
      if (this.printAreaRect) {
        this.printAreaRect.destroy();
      }
      
      const config = PRINT_AREA_CONFIG[this.id];
      if (!config) return;
      
      const b = this.bounds;
      const printX = b.x + (b.w * config.x);
      const printY = b.y + (b.h * config.y);
      const printW = b.w * config.width;
      const printH = b.h * config.height;
      
      this.printBounds = {
        x: printX,
        y: printY,
        w: printW,
        h: printH
      };
      
      this.printAreaRect = new Konva.Rect({
        x: printX,
        y: printY,
        width: printW,
        height: printH,
        stroke: '#00ff00',
        strokeWidth: 2,
        dash: [10, 5],
        listening: false,
        name: 'printArea'
      });
      
      this.layerBg.add(this.printAreaRect);
      this.layerBg.draw();
    }

    calculateNodeDPI(node) {
      if (!node) return null;

      const img = node.image();
      if (!img) return null;

      const naturalWidth = img.naturalWidth || img.width;
      const naturalHeight = img.naturalHeight || img.height;
      const rect = node.getClientRect({ relativeTo: this.stage });
      const widthInches = (rect.width / this.stage.width()) * STAGE_REFERENCE_INCHES;
      const heightInches = (rect.height / this.stage.height()) * STAGE_REFERENCE_INCHES;

      if (widthInches <= 0 || heightInches <= 0) return null;

      return calculateDPI(naturalWidth, naturalHeight, widthInches, heightInches);
    }

    updateDPIForNode(node) {
      const dpi = this.calculateNodeDPI(node);
      if (dpi) {
        this.updateDPIDisplay(dpi);
      }
    }

    updateDPIDisplay(dpi) {
      if (!this.dpiBadge) return;

      const quality = getDPIQuality(dpi);
      const dpiRounded = Math.round(dpi);
      
      this.dpiBadge.textContent = `DPI: ${dpiRounded} (${quality.level})`;
      this.dpiBadge.style.display = 'inline-block';
      this.dpiBadge.style.background = quality.bg;
      this.dpiBadge.style.color = quality.color;
      this.dpiBadge.style.fontWeight = '600';
    }

    hideDPIDisplay() {
      if (this.dpiBadge) {
        this.dpiBadge.style.display = 'none';
      }
    }

    handleTextButton(){
      if(!this.textControls.wrapper) return;
      const isVisible=this.textControls.wrapper.style.display==='flex';
      if(isVisible){
        this.hideTextControls();
        return;
      }
      const sel=this.selected();
      if(sel && this.isTextNode(sel)){
        this.populateTextForm(sel);
        this.textControls.wrapper.dataset.mode='edit';
        if(this.textControls.apply){ this.textControls.apply.textContent='Update Text'; }
      }else{
        this.prepareTextFormDefaults();
        this.textControls.wrapper.dataset.mode='add';
        if(this.textControls.apply){ this.textControls.apply.textContent='Place Text'; }
      }
      this.textControls.wrapper.style.display='flex';
      if(this.textControls.input){
        this.textControls.input.focus();
        this.textControls.input.select();
      }
    }

    hideTextControls(){
      if(!this.textControls.wrapper) return;
      this.textControls.wrapper.style.display='none';
      this.textControls.wrapper.dataset.mode='add';
      if(this.textControls.apply){ this.textControls.apply.textContent='Place Text'; }
      this.prepareTextFormDefaults();
    }

    prepareTextFormDefaults(){
      if(!this.textControls.wrapper) return;
      if(this.textControls.input){ this.textControls.input.value=''; }
      if(this.textControls.font){
        const fallback=this.textDefaults.font;
        const desired=fallback;
        const hasOption=Array.from(this.textControls.font.options||[]).some(opt=>opt.value===desired);
        if(hasOption){
          this.textControls.font.value=desired;
        }else{
          this.textControls.font.selectedIndex=0;
        }
      }
      if(this.textControls.size){
        this.textControls.size.value=this.textDefaults.size;
      }
      if(this.textControls.color){
        this.textControls.color.value=this.textDefaults.color;
      }
    }

    populateTextForm(node){
      if(!this.textControls.wrapper || !node) return;
      if(this.textControls.input){ this.textControls.input.value=node.text?.() || ''; }
      if(this.textControls.font){
        const font=node.fontFamily?.() || this.textDefaults.font;
        const options=Array.from(this.textControls.font.options||[]);
        if(options.some(opt=>opt.value===font)){
          this.textControls.font.value=font;
        }else if(options.some(opt=>opt.value===this.textDefaults.font)){
          this.textControls.font.value=this.textDefaults.font;
        }else if(options.length){
          this.textControls.font.selectedIndex=0;
        }
      }
      if(this.textControls.size){
        const size=node.fontSize?.();
        this.textControls.size.value=size ? Math.round(size) : this.textDefaults.size;
      }
      if(this.textControls.color){
        this.textControls.color.value=this.colorToHex(node.fill?.());
      }
    }

    applyTextFromControls(){
      if(!this.textControls.wrapper) return;
      const textValue=(this.textControls.input?.value || '').trim();
      if(!textValue){
        alert('Please enter text.');
        this.textControls.input?.focus();
        return;
      }
      const fontFamily=this.textControls.font?.value || this.textDefaults.font;
      let fontSize=parseInt(this.textControls.size?.value,10);
      if(!Number.isFinite(fontSize)) fontSize=this.textDefaults.size;
      fontSize=Math.max(6, Math.min(96, fontSize));
      const color=this.textControls.color?.value || this.textDefaults.color;
      const mode=this.textControls.wrapper.dataset.mode || 'add';
      if(mode==='edit'){
        const sel=this.selected();
        if(sel && this.isTextNode(sel)){
          sel.text(textValue);
          sel.fontFamily(fontFamily);
          sel.fontSize(fontSize);
          sel.fill(color);
          sel.setAttr('label',`Text: ${textValue}`);
          sel.offsetX(sel.width()/2);
          sel.offsetY(sel.height()/2);
          this.clamp(sel);
          this.layerArt.draw();
          this.setSelected(sel);
          this.hideTextControls();
          markUnsaved();
          return;
        }
      }
      const targetBounds=this.printBounds || this.bounds;
      const textNode=new Konva.Text({
        text:textValue,
        fontFamily,
        fontSize,
        fill:color,
        align:'center',
        draggable:true,
        name:'draggableItem',
        label:`Text: ${textValue}`,
        padding:4
      });
      textNode.x(targetBounds.x + targetBounds.w/2);
      textNode.y(targetBounds.y + targetBounds.h/2);
      textNode.offsetX(textNode.width()/2);
      textNode.offsetY(textNode.height()/2);
      this.attachHandlersForNode(textNode);
      this.layerArt.add(textNode);
      this.clamp(textNode);
      this.layerArt.draw();
      this.setSelected(textNode);
      window.lastUpload={side:this,node:textNode};
      this.hideTextControls();
      markUnsaved();
    }

    colorToHex(color){
      if(!color) return this.textDefaults.color;
      try{
        if(typeof Konva==='undefined' || !Konva.Util || !Konva.Util.getRGB) throw new Error('no konva util');
        const rgb=Konva.Util.getRGB(color);
        if(!rgb || [rgb.r,rgb.g,rgb.b].some(v=>Number.isNaN(v))) throw new Error('invalid color');
        const toHex=v=> Math.max(0,Math.min(255,Math.round(v))).toString(16).padStart(2,'0');
        return `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`;
      }catch(e){
        return this.textDefaults.color;
      }
    }

    isTextNode(node){
      return !!(node && typeof node.getClassName==='function' && node.getClassName()==='Text');
    }

    attachArtworkHandlers(node,{type}={}){
      if(!node) return;
      node.off('dragmove');
      node.off('dragend');
      node.off('transform');
      node.off('transformend');
      node.on('dragmove',()=>{
        this.clamp(node);
        this.layerArt.batchDraw();
      });
      if(type==='text'){
        node.on('dragend',()=>{
          this.clamp(node);
          this.layerArt.draw();
          this.layerUI.batchDraw();
          markUnsaved();
        });
        node.on('transform',()=>{
          this.clamp(node);
          this.layerArt.batchDraw();
        });
        node.on('transformend',()=>{
          const scaleX=node.scaleX() || 1;
          const scaleY=node.scaleY() || 1;
          const avg=(scaleX+scaleY)/2;
          const baseSize=node.fontSize();
          node.fontSize(Math.max(6, baseSize*avg));
          node.scaleX(1);
          node.scaleY(1);
          node.offsetX(node.width()/2);
          node.offsetY(node.height()/2);
          this.clamp(node);
          this.layerArt.draw();
          this.layerUI.batchDraw();
          markUnsaved();
        });
      }else{
        node.on('dragend',()=>{
          this.updateDPIForNode(node);
          this.layerArt.draw();
          this.layerUI.batchDraw();
          markUnsaved();
        });
        node.on('transform',()=>{
          this.clamp(node);
          this.updateDPIForNode(node);
          this.layerArt.batchDraw();
        });
        node.on('transformend',()=>{
          this.updateDPIForNode(node);
          this.layerArt.draw();
          this.layerUI.batchDraw();
          markUnsaved();
        });
      }
    }

    attachHandlersForNode(node){
      if(!node) return;
      node.draggable(true);
      if(typeof node.name==='function'){ node.name('draggableItem'); }
      if(this.isTextNode(node)){
        node.offsetX(node.width()/2);
        node.offsetY(node.height()/2);
        node.setAttr('label',node.getAttr('label') || `Text: ${node.text?.()||''}`);
        this.attachArtworkHandlers(node,{type:'text'});
      }else{
        this.attachArtworkHandlers(node,{type:'image'});
      }
    }

    syncTextControlsForSelection(node){
      if(!this.textControls.wrapper) return;
      const isVisible=this.textControls.wrapper.style.display==='flex';
      if(node && this.isTextNode(node)){
        if(isVisible){
          this.populateTextForm(node);
          if(this.textControls.apply){ this.textControls.apply.textContent='Update Text'; }
        }
        this.textControls.wrapper.dataset.mode='edit';
      }else{
        if(isVisible){
          if(this.textControls.wrapper.dataset.mode!=='add'){
            this.prepareTextFormDefaults();
          }
          if(this.textControls.apply){ this.textControls.apply.textContent='Place Text'; }
        }
        this.textControls.wrapper.dataset.mode='add';
      }
    }

    async setBase(url){
      const img=url?await loadImage(url):null;
      if(!img){
        if(this.baseNode){ this.baseNode.destroy(); this.baseNode=null; this.layerBg.draw(); }
        this.bounds={x:0,y:0,w:this.stage.width(),h:this.stage.height()};
        return;
      }
      if(!this.baseNode){
        this.baseNode=new Konva.Image({image:img,listening:false});
        this.layerBg.add(this.baseNode);
      }else{
        this.baseNode.image(img);
      }
      const scale=Math.min(this.stage.width()/img.width, this.stage.height()/img.height);
      const w=img.width*scale, h=img.height*scale;
      const x=(this.stage.width()-w)/2, y=(this.stage.height()-h)/2;
      this.baseNode.setAttrs({x,y,width:w,height:h});
      this.layerBg.draw();
      this.bounds={x,y,w,h};
      this.drawPrintArea();
      this.layerArt.draw();
    }

    clamp(node){
      const b = this.printBounds || this.bounds;
      const r = node.getClientRect({relativeTo: this.stage});
      let dx = 0, dy = 0;
      
      if(r.x < b.x) dx = b.x - r.x;
      if(r.y < b.y) dy = b.y - r.y;
      if(r.x + r.width > b.x + b.w) dx = (b.x + b.w) - (r.x + r.width);
      if(r.y + r.height > b.y + b.h) dy = (b.y + b.h) - (r.y + r.height);
      
      node.x(node.x() + dx);
      node.y(node.y() + dy);
    }

    setSelected(node){
      this.tr.nodes(node?[node]:[]);
      this.layerUI.batchDraw();
      if(node){
        this.selBadge.textContent=`File: ${node.getAttr('label')||node.name()}`;
        const dpi=this.calculateNodeDPI(node);
        if(dpi){
          this.updateDPIDisplay(dpi);
        }else{
          this.hideDPIDisplay();
        }
      }else{
        this.selBadge.textContent='File: None';
        this.hideDPIDisplay();
      }
      this.syncTextControlsForSelection(node);
    }

    selected(){ return this.tr.nodes()[0] || null; }

    receiveClone(konvaNode){
      const clone=konvaNode.clone({listening:true});
      this.attachHandlersForNode(clone);
      this.layerArt.add(clone); this.clamp(clone); this.layerArt.draw(); this.setSelected(clone);
      window.lastUpload={side:this,node:clone};
      markUnsaved();
    }
  }

  // Instantiate 4 sides
  const front=new Side({
    id:'front',
    mountId:'stageFront',
    selBadgeId:'selFront',
    dpiBadgeId:'dpiFront',
    deleteBtnId:'delFront',
    uploadId:'upFront',
    textBtnId:'textFrontBtn',
    textControlsId:'textFrontControls',
    textInputId:'textFrontInput',
    textFontId:'textFrontFont',
    textSizeId:'textFrontSize',
    textColorId:'textFrontColor',
    textApplyId:'textFrontApply',
    textCancelId:'textFrontCancel'
  });
const back =new Side({
    id:'back',
    mountId:'stageBack',
    selBadgeId:'selBack',
    dpiBadgeId:'dpiBack',
    deleteBtnId:'delBack',
    uploadId:'upBack',
    textBtnId:'textBackBtn',
    textControlsId:'textBackControls',
    textInputId:'textBackInput',
    textFontId:'textBackFont',
    textSizeId:'textBackSize',
    textColorId:'textBackColor',
    textApplyId:'textBackApply',
    textCancelId:'textBackCancel'
  });
const left =new Side({
    id:'left',
    mountId:'stageLeft',
    selBadgeId:'selLeft',
    dpiBadgeId:'dpiLeft',
    deleteBtnId:'delLeft',
    uploadId:'upLeft',
    textBtnId:'textLeftBtn',
    textControlsId:'textLeftControls',
    textInputId:'textLeftInput',
    textFontId:'textLeftFont',
    textSizeId:'textLeftSize',
    textColorId:'textLeftColor',
    textApplyId:'textLeftApply',
    textCancelId:'textLeftCancel'
  });
const right=new Side({
    id:'right',
    mountId:'stageRight',
    selBadgeId:'selRight',
    dpiBadgeId:'dpiRight',
    deleteBtnId:'delRight',
    uploadId:'upRight',
    textBtnId:'textRightBtn',
    textControlsId:'textRightControls',
    textInputId:'textRightInput',
    textFontId:'textRightFont',
    textSizeId:'textRightSize',
    textColorId:'textRightColor',
    textApplyId:'textRightApply',
    textCancelId:'textRightCancel'
  });


// === CASCADING DROPDOWN FILTERING ===
const variantSel = document.getElementById('variantSel');
const vendorSel = document.getElementById('vendor');
const colorSel = document.getElementById('colorSel');

function resetColorSelector(message, disabled) {
  colorSel.innerHTML = '';
  const option = document.createElement('option');
  option.value = '';
  option.textContent = message;
  colorSel.appendChild(option);
  colorSel.disabled = disabled;
}

function setVariantLoadingState() {
  variantSel.innerHTML = '';
  const option = document.createElement('option');
  option.value = '';
  option.textContent = 'Loading variants...';
  variantSel.appendChild(option);
  variantSel.disabled = true;
  resetColorSelector('-- Select Hard Hat First --', true);
}

function setVariantErrorState(message) {
  variantSel.innerHTML = '';
  const option = document.createElement('option');
  option.value = '';
  option.textContent = message || 'Unable to load variants';
  variantSel.appendChild(option);
  variantSel.disabled = true;
  resetColorSelector('-- Variants unavailable --', true);
}

function loadVariants() {
  if (variantsPromise) return variantsPromise;

  setVariantLoadingState();

  variantsPromise = fetch('variants.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to load variants: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      if (!data || typeof data !== 'object' || Array.isArray(data)) {
        throw new Error('Variants data is invalid');
      }
      VARIANTS = data;
      updateVariantDropdown(vendorSel.value || '');
      return VARIANTS;
    })
    .catch(err => {
      console.error('Failed to load variants:', err);
      setVariantErrorState('Unable to load variants');
      variantsPromise = null;
      throw err;
    });

  return variantsPromise;
}

const COLOR_NAMES = [
  'White','Black','Yellow','Blue','Gray','Grey','Orange','Red','Green','Hi-Viz Yellow','Hi-Vis Yellow','Hi-Viz Orange','Hi-Vis Orange','Pink','Teal','Gold','Khaki','Navy Blue','Royal Blue','Forest Green','Performance Blue','Carbon','FiberMetal','White Carbon','HiVis Yellow'
];
const COLOR_LOOKUP = new Map(COLOR_NAMES.map(color => [color.toLowerCase(), color]));

function extractColor(variantName) {
  if (!variantName) return null;
  const segments = variantName.split(' - ').map(seg => seg.trim()).filter(Boolean);
  for (let i = segments.length - 1; i >= 0; i--) {
    const normalized = segments[i].toLowerCase();
    if (COLOR_LOOKUP.has(normalized)) {
      return COLOR_LOOKUP.get(normalized);
    }
  }
  return null;
}

function getBaseVariantName(variant) {
  if (!variant || !variant.name) return '';
  const segments = variant.name.split(' - ').map(seg => seg.trim()).filter(Boolean);
  if (!segments.length) return variant.name;

  const productCode = (variant.productCode || '').trim().toLowerCase();
  if (productCode && segments[segments.length - 1].toLowerCase() === productCode) {
    segments.pop();
  }

  const color = extractColor(variant.name);
  if (color) {
    const colorIndex = segments.findIndex(seg => seg.toLowerCase() === color.toLowerCase());
    if (colorIndex !== -1) {
      segments.splice(colorIndex, 1);
    }
  }

  return segments.join(' - ');
}

function getUniqueBaseVariants(filteredByVendor) {
  const baseNames = new Map();
  filteredByVendor.forEach(([key, v]) => {
    const baseName = getBaseVariantName(v) || v.name || key;
    const normalized = baseName.toLowerCase();
    if (!baseNames.has(normalized)) {
      baseNames.set(normalized, baseName);
    }
  });
  return Array.from(baseNames.values()).sort((a, b) => a.localeCompare(b));
}

function getColorsForBaseVariant(selectedVendor, baseVariantName) {
  const colors = new Set();
  Object.entries(VARIANTS || {}).forEach(([key, v]) => {
    if (selectedVendor && selectedVendor !== '' && selectedVendor !== 'Other') {
      if (v.vendor !== selectedVendor) return;
    }
    const baseName = getBaseVariantName(v);
    if (baseName === baseVariantName) {
      const color = extractColor(v.name);
      if (color) colors.add(color);
    }
  });
  return Array.from(colors).sort();
}

function updateVariantDropdown(selectedVendor) {
  const allVariants = Object.entries(VARIANTS || {});
  if (!allVariants.length) {
    variantSel.innerHTML = '';
    const defaultVariantOption = document.createElement('option');
    defaultVariantOption.value = '';
    defaultVariantOption.textContent = '-- No variants available --';
    variantSel.appendChild(defaultVariantOption);
    variantSel.disabled = true;
    resetColorSelector('-- Variants unavailable --', true);
    return;
  }

  const filteredByVendor = allVariants.filter(([key, v]) => {
    if (!selectedVendor || selectedVendor === '') return true;
    if (selectedVendor === 'Other') return true;
    return v.vendor === selectedVendor;
  });

  const baseVariants = getUniqueBaseVariants(filteredByVendor);

  variantSel.innerHTML = '';
  const defaultVariantOption = document.createElement('option');
  defaultVariantOption.value = '';
  defaultVariantOption.textContent = '-- Select Hard Hat --';
  variantSel.appendChild(defaultVariantOption);
  baseVariants.forEach(baseName => {
    const option = document.createElement('option');
    option.value = baseName;
    option.textContent = baseName;
    variantSel.appendChild(option);
  });

  variantSel.disabled = false;
  variantSel.value = '';
  resetColorSelector('-- Select Hard Hat First --', true);
}

function updateColorDropdown(selectedVendor, baseVariantName) {
  if (!baseVariantName || baseVariantName === '') {
    resetColorSelector('-- Select Hard Hat First --', true);
    return;
  }

  const colors = getColorsForBaseVariant(selectedVendor, baseVariantName);

  if (colors.length === 0) {
    resetColorSelector('-- No colors available --', true);
    return;
  }

  colorSel.innerHTML = '';
  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = '-- Select Color --';
  colorSel.appendChild(defaultOption);
  colors.forEach(color => {
    const option = document.createElement('option');
    option.value = color;
    option.textContent = color;
    colorSel.appendChild(option);
  });
  colorSel.disabled = false;
  colorSel.value = '';
}

function applyVariantBySelection(selectedVendor, baseVariantName, selectedColor) {
  if (!baseVariantName || !selectedColor || selectedColor === '') return;

  const match = Object.entries(VARIANTS || {}).find(([key, v]) => {
    if (selectedVendor && selectedVendor !== '' && selectedVendor !== 'Other') {
      if (v.vendor !== selectedVendor) return false;
    }
    const baseName = getBaseVariantName(v);
    if (baseName !== baseVariantName) return false;
    const variantColor = extractColor(v.name);
    if (variantColor !== selectedColor) return false;
    return true;
  });
  
  if (match) {
    const [key] = match;
    applyVariant(key);
  }
}

// Event listeners
vendorSel.addEventListener('change', () => {
  loadVariants()
    .then(() => {
      updateVariantDropdown(vendorSel.value);
    })
    .catch(() => {});
});

variantSel.addEventListener('change', () => {
  loadVariants()
    .then(() => {
      updateColorDropdown(vendorSel.value, variantSel.value);
    })
    .catch(() => {});
});

colorSel.addEventListener('change', () => {
  loadVariants()
    .then(() => {
      applyVariantBySelection(vendorSel.value, variantSel.value, colorSel.value);
    })
    .catch(() => {});
});

// Initialize on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    loadVariants().catch(() => {});
  });
} else {
  loadVariants().catch(() => {});
}

// Apply selected variant (also sync vendor)
async function applyVariant(key){
  const v = VARIANTS[key];
  if (!v) return;
  try {
    await Promise.all([
      front.setBase(v.front),
      back.setBase(v.back),
      left.setBase(v.left),
      right.setBase(v.right)
    ]);

    // Auto-populate vendor
    if (v.vendor){
      vendorSel.value = v.vendor;
    }
    
    // Auto-populate product code
    if (v.productCode) {
      document.getElementById('productStyle').value = v.productCode;
    }
  } catch(err){
    alert('Failed to load images: ' + (err?.message || err));
  }
}


  // Clone helpers
  function cloneToAll(fromSide){
    const sel=fromSide.selected(); if(!sel) return;
    [front,back,left,right].forEach(s=>{ if(s!==fromSide) s.receiveClone(sel); });
  }
  document.getElementById('cloneFtoAll').addEventListener('click', ()=> cloneToAll(front));
  document.getElementById('cloneBtoAll').addEventListener('click', ()=> cloneToAll(back));
  document.getElementById('cloneLtoAll').addEventListener('click', ()=> cloneToAll(left));
  document.getElementById('cloneRtoAll').addEventListener('click', ()=> cloneToAll(right));

function getVariantByKey(key){ return VARIANTS[key] || null; }

// Track whether user has edited the field
const productStyleInput = document.getElementById('productStyle');
let productStyleDirty = false;
productStyleInput.addEventListener('input', () => { productStyleDirty = true; });

// Remember which variants we’ve already auto-filled
const autoFilledVariantKeys = new Set();

function autoFillOncePerVariant(key){
  if (productStyleDirty) return;                 // user took over
  if (autoFilledVariantKeys.has(key)) return;    // already auto-filled this one
  const v = getVariantByKey(key);
  productStyleInput.value = (v && v.productCode) ? v.productCode : '';
  autoFilledVariantKeys.add(key);
}

// Initial pass
autoFillOncePerVariant(variantSel.value);

function attachUnsavedChangeListeners(){
  const fields = document.querySelectorAll('#vest-customizer-root input, #vest-customizer-root select, #vest-customizer-root textarea');
  fields.forEach(field => {
    ['input','change'].forEach(evt => {
      field.addEventListener(evt, event => {
        if (event && 'isTrusted' in event && event.isTrusted === false) return;
        if (field.type === 'file' && evt === 'change'){
          const files = field.files;
          if (!files || !files.length) return;
        }
        markUnsaved();
      });
    });
  });
}

attachUnsavedChangeListeners();

  const REQUIRED_CUSTOMER_FIELDS = [
    { id: 'custName', label: 'Customer Name' },
    { id: 'contactName', label: 'Contact Name' },
    { id: 'custEmail', label: 'Email' },
    { id: 'custPhone', label: 'Phone' },
    { id: 'salesOrder', label: 'Sales Order #' }
  ];

  function validateRequiredCustomerFields(){
    const missing = [];
    let firstInvalid = null;

    REQUIRED_CUSTOMER_FIELDS.forEach(({ id, label }) => {
      const el = document.getElementById(id);
      if (!el) return;
      const value = (el.value || '').trim();
      const isValid = value.length > 0;
      el.style.borderColor = isValid ? '#ddd' : '#ef4444';
      el.setAttribute('aria-invalid', isValid ? 'false' : 'true');
      if (!isValid) {
        missing.push(label);
        if (!firstInvalid) {
          firstInvalid = el;
        }
      }
    });

    if (firstInvalid) {
      alert(`Please complete the required fields:\n- ${missing.join('\n- ')}`);
      firstInvalid.focus();
      return false;
    }

    return true;
  }

  REQUIRED_CUSTOMER_FIELDS.forEach(({ id }) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', () => {
      const hasValue = (el.value || '').trim().length > 0;
      if (hasValue) {
        el.style.borderColor = '#ddd';
        el.setAttribute('aria-invalid', 'false');
      }
    });
  });

  /* ----------------
   * PDF (2×2 grid, JPG/PNG aware)
   * ---------------- */
  const { PDFDocument, rgb, StandardFonts } = PDFLib;

  async function fetchAsArrayBufferSafe(url){
    try{
      if(!url) return null;
      const r=await fetch(url,{mode:'cors'});
      if(!r.ok) return null;
      return await r.arrayBuffer();
    }catch(e){ console.warn('Fetch failed (continuing):', url, e); return null; }
  }
  async function embedImageAuto(pdf, ab, url){
    if(!ab) return null;
    const isJpg=/\.jpe?g($|\?)/i.test(url||'');
    return isJpg ? await pdf.embedJpg(ab) : await pdf.embedPng(ab);
  }

  document.getElementById('downloadProof').addEventListener('click', ()=>{
    if(!validateRequiredCustomerFields()) return;
    makeProofPDF().catch(err=>{ console.error('PDF generation error:',err); alert('Could not generate PDF. See console for details.'); });
  });

  async function makeProofPDF(){
    const key=variantSel.value;
    const v=VARIANTS[key]||{};
    const variantName=v.name||'Hard Hat';

    async function captureStageDataURL(side){
      if(!side || !side.stage || typeof side.stage.toDataURL!=='function') return null;
      const toggles=[];
      function hideNode(node){
        if(!node || typeof node.visible!=='function') return;
        toggles.push({node,visible:node.visible()});
        node.visible(false);
      }
      hideNode(side.layerUI);
      hideNode(side.printAreaRect);
      try{
        if(typeof side.stage.draw==='function'){ side.stage.draw(); }
        return side.stage.toDataURL({pixelRatio:2});
      }catch(err){
        console.warn('Stage capture failed', side.id, err);
        return null;
      }finally{
        for(let i=toggles.length-1;i>=0;i--){
          const item=toggles[i];
          try{ item.node.visible(item.visible); }catch(e){ /* ignore */ }
        }
        if(typeof side.stage.draw==='function'){ side.stage.draw(); }
      }
    }

    const [frontStageDataURL, backStageDataURL, leftStageDataURL, rightStageDataURL, logoAB] = await Promise.all([
      captureStageDataURL(front),
      captureStageDataURL(back),
      captureStageDataURL(left),
      captureStageDataURL(right),
      fetchAsArrayBufferSafe(LOGO_URL)
    ]);

    const pdf=await PDFDocument.create();
    const page=pdf.addPage([792,612]); // Landscape Letter
    const font=await pdf.embedFont(StandardFonts.Helvetica);
    const pageW=page.getWidth();

    // Header
    function drawCentered(text,y,size){ const w=font.widthOfTextAtSize(text,size); page.drawText(text,{x:(pageW-w)/2,y,size,font}); }
    drawCentered('Jendco Safety Supply - Custom Hard Hat Proof',540,14);
    drawCentered(variantName,520,12);
    if(logoAB){
      const logo=await embedImageAuto(pdf,logoAB,LOGO_URL);
      if(logo){ const lw=110, lh=(logo.height/logo.width)*lw; page.drawImage(logo,{x:60,y:560,width:lw,height:lh}); }
    }

    // Left details column (unchanged)
    const getVal=id=> (document.getElementById(id)?.value||'').trim();
    const selVendor=getVal('vendor');
    const vendor=(selVendor==='Other')?(getVal('vendorOther')||'Other'):selVendor;
    const qty=Math.max(0, parseInt(getVal('qty')||'0', 10) || 0);
    const details={
      vendor,
      productStyle:getVal('productStyle'),
      logoLoc:getVal('logoLoc'),
      qty,
      customer:{
        name:getVal('custName'),
        contact:getVal('contactName'),
        email:getVal('custEmail'),
        phone:getVal('custPhone'),
        so:getVal('salesOrder'),
        notes:getVal('custNotes')
      }
    };

    const labelColor=rgb(0.2,0.2,0.2);
    const leftX=60; let y=500; const lineH=14;
    function drawLabelValue(label,value,x,y,labelWidth=110){ page.drawText(label,{x,y,size:10,color:labelColor,font}); page.drawText((value||'—'),{x:x+labelWidth,y,size:10,font}); }
    drawLabelValue('Vendor:',details.vendor,leftX,y); y-=lineH;
    drawLabelValue('Product Style:',details.productStyle,leftX,y); y-=lineH;
    drawLabelValue('Logo Location:',details.logoLoc,leftX,y); y-=lineH+8;
    drawLabelValue('Quantity:',String(details.qty||0),leftX,y); y-=lineH+12;

    y -= lineH * 14;  // ⬅️ move down 4 lines first
page.drawText('Customer Information',{x:leftX,y,size:11,font}); 
y -= lineH+8;
    drawLabelValue('Customer Name:',details.customer?.name||'—',leftX,y); y-=lineH;
    drawLabelValue('Contact Name:',details.customer?.contact||'—',leftX,y); y-=lineH;
    drawLabelValue('Email:',details.customer?.email||'—',leftX,y); y-=lineH;
    drawLabelValue('Phone:',details.customer?.phone||'—',leftX,y); y-=lineH;
    drawLabelValue('Sales Order #:',details.customer?.so||'—',leftX,y); y-=lineH;
    drawLabelValue('Notes:', details.customer?.notes || '—', leftX, y); y -= lineH;

    // ===== 2×2 GRID of helmet views (Front/Back, Left/Right) =====
    const LEFT_BLOCK_WIDTH = 260, LEFT_MARGIN = 15, RIGHT_MARGIN = 40, OUTER_GAP = 24, GAP = 16;
    const gridX   = LEFT_MARGIN + LEFT_BLOCK_WIDTH + OUTER_GAP; // start of the grid area
    const gridTop = 350;                                       // below header
    const usableW = pageW - RIGHT_MARGIN - gridX;
    const usableH = 410;                                       // down to footer

    const COLS = 2, ROWS = 2;
    const maxW = Math.floor((usableW - (COLS - 1) * GAP) / COLS);
    const maxH = Math.floor((usableH - (ROWS - 1) * GAP) / ROWS);
    const card  = Math.min(maxW, maxH, 130); // square tile size cap
    const cardW = card, cardH = card;

    async function drawSide(stageDataUrl, xLeft, yTop, label){
      if(stageDataUrl){
        try{
          const stageBuf=await (await fetch(stageDataUrl)).arrayBuffer();
          const stageImg=await pdf.embedPng(stageBuf);
          const scale=Math.min(cardW/stageImg.width, cardH/stageImg.height);
          const drawW=stageImg.width*scale;
          const drawH=stageImg.height*scale;
          const drawX=xLeft+(cardW-drawW)/2;
          const drawY=yTop+(cardH-drawH)/2;
          page.drawImage(stageImg,{ x:drawX, y:drawY, width:drawW, height:drawH });
        }catch(err){
          console.warn('Failed to embed stage for', label, err);
        }
      }
      const w=font.widthOfTextAtSize(label,10);
      page.drawText(label,{ x:xLeft+(cardW-w)/2, y:yTop-14, size:10, font });
    }

    // Grid coordinates (PDF y increases upward; subtract to go down a row)
    const x1 = gridX;
    const x2 = gridX + cardW + GAP;
    const y1 = gridTop;
    const y2 = gridTop - (cardH + GAP);

    // Row 1: Front | Back
    await drawSide(frontStageDataURL, x1, y1, 'Front');
    await drawSide(backStageDataURL,  x2, y1, 'Back');

    // Row 2: Left | Right
    await drawSide(leftStageDataURL,  x1, y2, 'Left');
    await drawSide(rightStageDataURL, x2, y2, 'Right');

// ---- Right-side column of logo previews (Front, Back, Left, Right) ----

// ---- Right-side column of logo previews (Front, Back, Left, Right) ----

// Return latest placed artwork node on a side (Konva-safe)
function getLatestArtNode(side){
  if (!side || !side.layerArt || typeof side.layerArt.getChildren !== 'function') return null;
  const coll = side.layerArt.getChildren(); // Konva.Collection
  const arr = typeof coll.toArray === 'function' ? coll.toArray() : Array.from(coll || []);
  // Uploaded logos are Konva.Image nodes
  const images = arr.filter(n => n && typeof n.getClassName === 'function' && n.getClassName() === 'Image');
  return images.length ? images[images.length - 1] : null;
}

// Snapshot a Konva.Image node into a PDF-embeddable PNG
async function embedKonvaNodeAsPng(pdf, node){
  if (!node || typeof node.image !== 'function') return null;
  const el = node.image(); if (!el) return null;
  const sw = el.naturalWidth || el.width || 0;
  const sh = el.naturalHeight || el.height || 0;
  if (!sw || !sh) return null;

  const cnv = document.createElement('canvas');
  cnv.width = sw; cnv.height = sh;
  cnv.getContext('2d').drawImage(el, 0, 0, sw, sh);
  const ab = await (await fetch(cnv.toDataURL('image/png'))).arrayBuffer();
  return await pdf.embedPng(ab);
}

// Layout for the right column (REUSE existing RIGHT_MARGIN from the grid)
const boxW = 90, boxH = 90, gapY = 18;
const colX = pageW - RIGHT_MARGIN - boxW; // <-- use existing RIGHT_MARGIN, do NOT redeclare
let boxY = 480; // start near the grid; lower this to move the column down

// Order: Front, Back, Left, Right (top -> bottom)
const order = [
  { label: 'Front', side: front },
  { label: 'Back',  side: back  },
  { label: 'Left',  side: left  },
  { label: 'Right', side: right }
];

// Draw top → bottom
for (const item of order){
  // Label above each box
  const t = `Logo: ${item.label}`;
  const tw = font.widthOfTextAtSize(t, 9);
  page.drawText(t, { x: colX + (boxW - tw)/2, y: boxY + boxH + 8, size: 9, font, color: rgb(0.25,0.25,0.25) });

  // Box border
  page.drawRectangle({
    x: colX - 2, y: boxY - 2,
    width: boxW + 4, height: boxH + 4,
    borderColor: rgb(0,0,0), borderWidth: 2
  });

  // Image if that side has artwork; otherwise leave it blank
  try {
    const node = getLatestArtNode(item.side);
    const img  = await embedKonvaNodeAsPng(pdf, node);
    if (img){
      const s  = Math.min(boxW / img.width, boxH / img.height);
      const dw = img.width * s, dh = img.height * s;
      page.drawImage(img, { x: colX + (boxW - dw)/2, y: boxY + (boxH - dh)/2, width: dw, height: dh });
    }
  } catch (e) {
    console.warn('Logo preview failed for', item.label, e);
    // leave box empty
  }

  // next box position (move downward)
  boxY -= (boxH + gapY + 16);
}
    // Footer
    const disclaimer="Images are for proofing purposes only. Final placement/size/color may vary. Color appearance varies by monitor.";
    page.drawText(disclaimer,{x:60,y:120,size:9,font,color:rgb(0.25,0.25,0.25)});
    page.drawText("Approved (Y/N): ______    Date: ______    Signature: __________________________",{x:60,y:90,size:10,font});
    const ts=new Date(); page.drawText(`Generated: ${ts.toLocaleString()}`,{x:60,y:60,size:9,font,color:rgb(0.3,0.3,0.3)});

    // Download
    const bytes=await pdf.save();
    const blob=new Blob([bytes],{type:'application/pdf'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
    a.download=`Proof_${(variantName||'HardHat').replace(/\s+/g,'')}.pdf`; a.click();
    setTimeout(()=> URL.revokeObjectURL(a.href), 1000);
    markSaved();
  }

  // Button cosmetics (JS-injected so WYSIWYG can’t strip)
  Array.prototype.forEach.call(document.querySelectorAll('#vest-customizer-root .btn'), function(btn){
    btn.style.display='inline-block';
    btn.style.padding='10px 18px';
    btn.style.borderRadius='8px';
    btn.style.border='2px solid #111';
    btn.style.background='linear-gradient(#ff8c00,#e67300)';
    btn.style.color='#fff';
    btn.style.fontWeight='600';
    btn.style.fontSize='14px';
    btn.style.boxShadow='0 3px 6px rgba(0,0,0,.25)';
    btn.style.cursor='pointer';
    btn.addEventListener('mouseenter', function(){ btn.style.transform='translateY(-2px)'; btn.style.boxShadow='0 6px 12px rgba(0,0,0,.3)'; });
    btn.addEventListener('mouseleave', function(){ btn.style.transform=''; btn.style.boxShadow='0 3px 6px rgba(0,0,0,.25)'; });
  });
})();
</script>

</p>

